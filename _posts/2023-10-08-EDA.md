
## 이벤트 기반 아키텍처
	* Microserivce Architecture(MSA)는 Loosly couple를 기반으로 빠른 배포주기, Ployglot Programming, 관심사의 집중 등의 장점을 발휘해 
	  Enterprise IT에서 주목받는 아키텍처로 분해된 서비스의 Scalability, Resiliency 등 Cloud 기반의 플랫폼과 어우러지면서 발전하고 있음
	* 하나의 Microservice는 Database per service!
	  Rest 통신(Synchronized) 으로 인한 제약사항
	  분산된 서비스간의 트랜잭션 처리방안
	* EDA는 MSA가 적용된 시스템에서 이벤트를 생성/발행 시키고 해당 이벤트를 필요로 하는 수신자에게 전송하면 이벤트를 구독하고 있던 수신자가 
	  이벤트를 받아서 처리하는 형태의 아키텍처

## 비동기 메시징으로 가용성 개선
	* REST 통신(동기통신)은 대중적이지만 호출한 서비스가 응답할 때 까지 클라이언트가 대기해야 하고, 그로 인해 가용성은 저하되는 문제점을 가지고 있음
	1) 해지 이벤트 발행
	2) 고객,수납 서비스는 "해지됨" 이벤트 구독
	3) 고객서비스는 "해지됨" 이벤트를 구독하여 고객 상태를 "해지"로 변경
	4) 수납서비스는 "해지됨" 이벤트를 구독하여 수납 상태를 "수납완료"로 변경

## 도메인 이벤트
	* 도메인 이벤트는 애그리거트에서 발생하는 사건
	* 애그리거트는 뭔가 생성되거나 중요한 변경이 발생했을 때 도매인 이벤트를 발행함
	* "계약" 애그리거트라면 신규계약처리됨, 계약해지됨, 계약일시정지됨 등 상태가 바뀌는 이벤트를 발행
	* 애그리거트는 상태가 전이될 때 마다 이에 관련된 컨슈머를 위해 이벤트를 발행
	* 변경 이벤트를 발행하는 이유? 타 서비스가 애그리거트의 상태 변경을 궁금해 하기 때문 
	* 컨슈머가 이벤트를 받아서 처리하려면 계약내용이 필요함, 컨슈머에 필요한 정보를 이벤트가 가지고 다니는 것을 권장하고
	  이벤트를 발행한 서비스를 다시 쿼리해서 데이터를 가져올 필요가 없으니 컨슈머가 간단해짐

## 주의할 점
	* 애그리거트의 상태 전이를 단순히 DB의 CDC 변경분이라고 생각하는 경우 많은데 테이블의 DML 관점의 create, update, delete와는 격이 다른
	  도메인의 변경이라는 것에 촛점을 맞추어야 함
	* 도메인의 이벤트를 적용하는 것을 단순히 인터페이스목록, API목록, EAI로 단순하게 매핑하여 접근하는 경우가 많은데 엄연히 차이가 있다는 것을 인지해야함

## 서비스 연관 관계 파악
	1) SRD를 작성하면서 비동기의 경우 해당하는 주요 data는 애그리거트 후보로 도출
	2) 핵심 데이터(애그리거트 후보)의 도메인 이벤트 추출
	3) 서비스간 비동기 메시지 정의

## 메시징 유형
	* 이벤트 Pub/Sub
		+ 서비스는 도메인 객체의 변경사실을 알리는 도메인 이벤트를 발행하고 타서비스는 관심 있는 이벤트를 구독 (1:N관계 비동기 처리에 사용, Choreography saga 패턴)
	* Command-Reply
		+ 요청하는 서비스와 응답하는 서비스가 짝을 이루고, 응답을 기다리지 않고 비동기로 처리함(1:1 비동기요청/응답, Orchestration Saga 패턴)
	* Message
		+ 단순 메시지를 주고받기 위한 발행/구독 용도로 사용하는 단방향 메시지(SMS,Email, 서비스의 응답을 반환하지 않음)

## 비동기 메시지 처리
	* On-premise에서 구현된 local Transaction처리를 비동기 메시지로 설계
	* 비동기 메시지설계로 Saga 패턴 정의, 보상설계 서비스의 역할과 책임을 분명히 정의하고 파트간의 조율하고 협의하는 session이 필요함 