
## 이벤트 기반 아키텍처
	* Microserivce Architecture(MSA)는 Loosly couple를 기반으로 빠른 배포주기, Ployglot Programming, 관심사의 집중 등의 장점을 발휘해 
	  Enterprise IT에서 주목받는 아키텍처로 분해된 서비스의 Scalability, Resiliency 등 Cloud 기반의 플랫폼과 어우러지면서 발전하고 있음
	* 하나의 Microservice는 Database per service!
	  Rest 통신(Synchronized) 으로 인한 제약사항
	  분산된 서비스간의 트랜잭션 처리방안
	* EDA는 MSA가 적용된 시스템에서 이벤트를 생성/발행 시키고 해당 이벤트를 필요로 하는 수신자에게 전송하면 이벤트를 구독하고 있던 수신자가 
	  이벤트를 받아서 처리하는 형태의 아키텍처

## 비동기 메시징으로 가용성 개선
	* REST 통신(동기통신)은 대중적이지만 호출한 서비스가 응답할 때 까지 클라이언트가 대기해야 하고, 그로 인해 가용성은 저하되는 문제점을 가지고 있음
	1) 해지 이벤트 발행
	2) 고객,수납 서비스는 "해지됨" 이벤트 구독
	3) 고객서비스는 "해지됨" 이벤트를 구독하여 고객 상태를 "해지"로 변경
	4) 수납서비스는 "해지됨" 이벤트를 구독하여 수납 상태를 "수납완료"로 변경

## 도메인 이벤트
	* 도메인 이벤트는 애그리거트에서 발생하는 사건
	* 애그리거트는 뭔가 생성되거나 중요한 변경이 발생했을 때 도매인 이벤트를 발행함
	* "계약" 애그리거트라면 신규계약처리됨, 계약해지됨, 계약일시정지됨 등 상태가 바뀌는 이벤트를 발행
	* 애그리거트는 상태가 전이될 때 마다 이에 관련된 컨슈머를 위해 이벤트를 발행
	* 변경 이벤트를 발행하는 이유? 타 서비스가 애그리거트의 상태 변경을 궁금해 하기 때문 
	* 컨슈머가 이벤트를 받아서 처리하려면 계약내용이 필요함, 컨슈머에 필요한 정보를 이벤트가 가지고 다니는 것을 권장하고
	  이벤트를 발행한 서비스를 다시 쿼리해서 데이터를 가져올 필요가 없으니 컨슈머가 간단해짐

## 주의할 점
	* 애그리거트의 상태 전이를 단순히 DB의 CDC 변경분이라고 생각하는 경우 많은데 테이블의 DML 관점의 create, update, delete와는 격이 다른
	  도메인의 변경이라는 것에 촛점을 맞추어야 함
	* 도메인의 이벤트를 적용하는 것을 단순히 인터페이스목록, API목록, EAI로 단순하게 매핑하여 접근하는 경우가 많은데 엄연히 차이가 있다는 것을 인지해야함

## 서비스 연관 관계 파악
	1) SRD를 작성하면서 비동기의 경우 해당하는 주요 data는 애그리거트 후보로 도출
	2) 핵심 데이터(애그리거트 후보)의 도메인 이벤트 추출
	3) 서비스간 비동기 메시지 정의

## 메시징 유형
	* 이벤트 Pub/Sub
		+ 서비스는 도메인 객체의 변경사실을 알리는 도메인 이벤트를 발행하고 타서비스는 관심 있는 이벤트를 구독 (1:N관계 비동기 처리에 사용, Choreography saga 패턴)
	* Command-Reply
		+ 요청하는 서비스와 응답하는 서비스가 짝을 이루고, 응답을 기다리지 않고 비동기로 처리함(1:1 비동기요청/응답, Orchestration Saga 패턴)
	* Message
		+ 단순 메시지를 주고받기 위한 발행/구독 용도로 사용하는 단방향 메시지(SMS,Email, 서비스의 응답을 반환하지 않음)

## 비동기 메시지 처리
	* On-premise에서 구현된 local Transaction처리를 비동기 메시지로 설계스키
	* 비동기 메시지설계로 Saga 패턴 정의, 보상설계 서비스의 역할과 책임을 분명히 정의하고 파트간의 조율하고 협의하는 session이 필요함 

## 분산 트랜잭션
	* 데이터 정합성을 유지하기 위해 사용가능한 방법
	1) 대기 또는 실패 시 재호출
	2) Batch 작업 등으로 실패건 일괄 취소
	3) 보상 트랜잭션 처리(Saga 패턴 적용, 프로세스 및 데이터 분산에 따른 복잡성이 추가됨)

## 장애사례
	* e-commerce 비지니스에서의 부하는 주로 가격이벤트 등 비주기적 행사에서 발생
	* 특정 상품의 가격을 특정일자에 가격할인 이벤트를 하게 되면 사용자가 일시적으로 몰리면서 부하가 발생하는 패턴임
	  이는 write 트랜잭션보다는 read 트랜잭션 부하가 많음을 의미함
	* 장애 회피 설계 방안
		+ 부하가 집중되는 업무는 시스템적인 확장도 중요하지만 더욱 중요한 것은 비즈니스 처리 단계를 추가하여 점진적으로 부하를 경감시키는 것임
		  DB나 서버 성능을 확장하여 부하를 감당하는 것에는 한계가 존재함
		+ 메인화면 조회 부하 > 상품내역 조회 부하 > 주문생성 부하
		  각 부하를 회피하는 방법은 의외로 간단하다. 이벤트에 참여하고자 하는 회원이 메인화면, 상품화면, 주문화면에 접근하지 못하게 하는 것이다.
		  선착순 이벤트 단순 신청화면을 만들고 해당 DB를 분리하면 부하는 줄일 수 있음
		+ 아무리 좋은 환경의 MSA를 구축하더라도 사용자 집중으로 인한 부하를 막기는 어려움


## 자료정리

### MSA 모델링

### INNER

### 데이터베이스 구성
	1) 고객사의 특성 및 서비스의 특성에 따라 WAS만을 별개로 구성하고 DB는 Shared DB로 구성하는 경우도 있다.
	* 계정/스키마 미분리 구성
	* 계정만 분리 구성
	* 스키마만 분리 구성
	* 계정/스키마 분리구성
	이렇게 되면 단계별로 data dependency의 유지 정도가 달라지고 DB instance를 같이 쓴다는 측면에서 DB의 장애 전파나, DB Connection을 공유하는 문제는 감수하여야 하나
	Data나 DB Instance에 따른 비용 및 유지보수 용이성 측면에서의 강점이 있으므로 고객사 현장의 특성에 맞는 대안이 될 수 있음

### Shared DB 구성 방안
	* DB통합배경
		- SM의 관리 부담 고려
		- 고객사의 요청
		- 서비스 간 데이터 연관도가 높고 Join 쿼리가 다수
		- 오라클과 OSS DB의 성능 차이 고려
		- DB 사이즈가 작아 DB instance 분리의 부담
		- SQL문 재활용 필요성 제기
	* 절충안으로 Shared DB에 계정과 스키마를 분리하는 것으로 고려
	* DB계정이 다른 마이크로서비스 간의 데이터 참조(CRUD)는 직접 접근이 불가함
	* 마이크로서비스가 타 서비스의 테이블을 참조해야 하는 경우는 타 서비스에서 제공하는 API를 호출하여 응용에서 데이터를 조합하는것이 원칙
	* <span style="background-color:#fff5b1">단, 성능을 고려하여 테이블 복제, CQRS 구성 등의 기법 검토(데이터가 자주 변경되지 않고, Near Real Time 데이터 제공이 가능한 경우)</span>
	1) Api Composition
	2) 분산 데이터 조회(CQRS)
	3) 분산 트랜잭션 정책(SAGA패턴(보상트랜잭션)) 

### API 설계
	* Consumer 주도 식별 : 주는 쪽은 누가 내 API를 쓰는지 뭘 줘야 되는지 모를 수 있지만 사용하는 쪽은 필요한 내용을 정확히 알 수 있기 때문
	* URI 포맷 : /auth/com/v1/create/user

	* 비동기 호출
		- 비동기는 분산 서비스 환경에서 서비스간 트랜잭션 호출 방식에서 우선적으로 고려되어야 하는 호출 전략이며 업무 성격에 따라 Notification전략과 처리 순서가 보장되지 않는 특성을 고려한 설계가 필요함

	* 타 마이크로서비스 연계 패턴
		1) Join 해소 - API Compostion
			* Join은 Join에 해당하는 데이터를 API 파라미터를 넘기고, 결과를 리턴받아서 응용 프로그램 내에서 조합하여 사용한다.
		2) 반정규화 - 컬럼 추가
			* Join 해소 시 특정값 한두개만 가져올 경우 API Composition 외에 반정규화를 통한 Join 해소를 고려한다.
			* 고려사항
				- 원본 Table이 먼저 insert 되는 경우 : 컬럼추가 table에 insert 시 원본 테이블의 값을 읽어 해당값을 같이 Insert 한다.
				- 컬럼추가 table이 먼저 insert 되는 경우 : 원본 table에 insert 될때 api를 호출하여 컬럼추가 table에도 해당값을 update 한다.
		3) 테이블 복제
			* 일부 컬럼 만으로는 join 해소가 불가능할 경우 table을 복제해 오는 것을 고려한다.
			* table 복제는 kafka의 connector 기능을 활용한다.
			* 복제해오는 서비스 내에서는 복제된 테이블을 참조하는 모든 쿼리는 원본을 바라보지 않고 복제된 table을 바라본다.(정합성 유지)

### 시스템 명세화
	* 각 레이어별 클래스와 클래스가 갖는 기능 및 API가 식별된다.
	* 타 서비스/시스템 간의 Interaction을 식별한다.
	* 이벤트스토밍 방법의 서비스 식별시 분석단계 SRD를 바탕으로 동기/비동기API/대내외IF를 파악한다.
	* 상세설계/개발로 가기 우ㅏ한 기초가 완성된다.

### 결론
	* 하나의 마이크로서비스는 완결성 있는 트랜잭션을 처리하도록 설계
	* 마이크로서비스 간 동기/비동기 설계를 중심으로 디자인
	* 서비스의 독립성 확보를 위해 비동기식 event 방식으로 서비스 간 연동
	* 다중 마이크로서비스 데이터 조회는 Api Compostion, 데이터 복제 등으로 해소하고, 해당 방안으로 불가할 경우 CQRS를 활용
	* 여러 마이크로서비스가 관련된 분산트랜잭션은 보상 처리 필요 시 saga 패턴을 활용하되 보상 트랜잭션 최소화 설계

### framework
	* 주요기능
		- GUID 채번, 서비스 연계 API, 카프카 연계 API, Exception 처리, 로그/모니터링
		- 필터 : 요청 및 응답에 대한 값 조회 및 공통 처리 수행

	* 로그
		- 이미지로그/업무로그/에러로그 > kafka producer >> kafka > schema registry > kafka connect >> 이미지로그DB/업무로그DB/에러로그DB	
		- 카프카 토픽은 날짜별로 총 31개 한달마다 초기화

### OUTER

1. 개요



